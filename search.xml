<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>近期博客站点的更新</title>
    <url>//posts/2020/03/23/2020-44-%E8%BF%91%E6%9C%9F%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9%E7%9A%84%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>最近再次对博客站点进行了一番比较大的更新升级，主要是成功解决了几个历史性遗留问题，例如访问的速度、图片没有缩略图预览、自定义样式代码不太清楚等等。经过这一次的改造，感觉未来短期内大规模的更新变动应该不会有了，毕竟主要的需求都已经实现。<a id="more"></a></p><h2 id="1-部署到对象存储"><a href="#1-部署到对象存储" class="headerlink" title="1. 部署到对象存储"></a>1. 部署到对象存储</h2><p>这其中主要的变动是更新了主题，以及从 Netlify 迁移到了阿里云对象存储（OSS），并且把部分的静态文件（css，js 和图像文件）放到了腾讯云对象存储（COS），还在腾讯云的对象存储上套了一层国内的 CDN 加速。</p><p>之所以这样区分是因为：腾讯云有每月对象存储免费额度和 CDN 免费流量额度，但是自定义域名绑定存储桶且开启 https 一定要通过 CDN 托管证书（不论境内外存储桶），而因为 CDN 要走国内节点所以一定要备案，故不能单独用腾讯云；阿里云对象存储可以解决上述问题，但是免费额度比较少，而且没有备案的域名虽然可以开启 https 但是一定要绑定非中国大陆节点的存储桶（如中国香港），因此将部分不需要自定义域名但是常常需要访问的资源放到腾讯云的存储桶加上国内 CDN 是非常有用的。我还使用腾讯云的云函数功能，每当存储桶有变动时候就让云函数去自动触发刷新各个节点缓存。</p><h2 id="2-持续集成与缩略图"><a href="#2-持续集成与缩略图" class="headerlink" title="2. 持续集成与缩略图"></a>2. 持续集成与缩略图</h2><p>这样，随之而来的问题就是部署站点，因为现在需要同时传输到两个地方。之前我采用的持续集成方案是 Travis CI，不过有一个问题是开始构建前的环境准备要比较长的时间。相比较而言，新出的 GitHub Actions 不仅启动比较快，而且集成在 GitHub 的代码仓库中，使用起来十分方便。另外，我还利用 GitHub Actions 拓展了一个新功能，也即每一次成功执行构建任务都会通过 Telegram bot 向我推送一条消息提醒（比邮件提醒方式方便多了）。</p><p>最后，因为 NexT 主题的 Fancybox 图片插件处理时没有提供缩略图的选项，使得每次加载图片都会载入原图。这样使得对象存储外网流出流量变大，而且会让访客浏览网页时加载速度偏慢。针对这一问题，我选择了一种对主题文件无损的修改方式来完成这个需求：在 GitHub Actions 工作流中利用 <code>sed</code> 的替换命令来实现对主题文件的临时性修改，从而实现图片默认显示缩略图、点击放大加载原图的效果。</p><h2 id="3-重构自定义样式"><a href="#3-重构自定义样式" class="headerlink" title="3. 重构自定义样式"></a>3. 重构自定义样式</h2><p>通过重构自定义样式，规范化了样式的格式，加入了每个样式的注释，还利用了 <code>mixins.styl</code> 样式文件。另外，因为 NexT 主题添加了黑暗模式和更新图标到 Font Awesome 5，所以也进行了色彩和图标调整适配。同时响应全国哀悼日对新冠肺炎疫情中逝世同胞和牺牲烈士的哀悼，加入了一个全站黑白样式，可以通过配置文件来打开关闭。</p><p>以上这些变动，都可以查阅我的 <a href="https://github.com/lei2rock/blog/blob/src/.github/workflows/deployment.yml" target="_blank" rel="noopener">GitHub Actions 脚本</a> 以及博客的 <a href="https://github.com/lei2rock/blog" target="_blank" rel="noopener">代码仓库</a> 了解。最后，放上博客的测速结果地图。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/03/speed-test.jpg!500x" alt="网站测速结果"></p>]]></content>
      <categories>
        <category>科技树</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>对象存储</tag>
        <tag>GitHub Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>部署 RSS 订阅服务 FreshRSS</title>
    <url>//posts/2020/04/15/2020-48-%E9%83%A8%E7%BD%B2RSS%E8%AE%A2%E9%98%85%E6%9C%8D%E5%8A%A1FreshRSS/</url>
    <content><![CDATA[<p>RSS 订阅我之前是使用 Inoreader，但是免费版的即使是在 Reeder 客户端下浏览依然是有广告植入的，而且听闻最近在境内已经无法访问了，所以就考虑自建一个。一开始考虑的是 Tiny Tiny RSS，这个之前在腾讯云的学生机上就尝试搭建过。但是订阅源的自动刷新一直搞不定，看了很多教程也没有成功，而且界面设置什么的都不是很喜欢，就放弃了。继续寻找之下找到了 FreshRSS，自带支持 Reeder 客户端访问，不像 Tiny Tiny RSS 还需要安装 fever 插件。<a id="more"></a></p><h2 id="1-安装-FreshRSS"><a href="#1-安装-FreshRSS" class="headerlink" title="1. 安装 FreshRSS"></a>1. 安装 FreshRSS</h2><div class="note info"><p><strong>注意</strong>：需要确认已经安装了 PHP 扩展 fileinfo。如果使用宝塔面板，可以参考我上一篇文章的说明安装该扩展，此外还需要取消禁用两个函数：openlog 和 syslog（不然安装设置过程中会报错）。</p></div><p>接下来在宝塔面板创建新站点，设置好数据库与 PHP 版本（还可以添加上 SSL 证书）：</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/04/create_site.jpg!500x" alt="创建新站点"></p><p>然后，删去网站根目录下默认添加创建的所有文件，确保文件夹全部清空。打开 SSH 终端，把 FreshRSS 源代码拉取到网站根目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/wwwroot/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/FreshRSS/FreshRSS.git rss</span><br></pre></td></tr></table></figure><p>接下来，我们需要提升网站根目录下 <code>/data/</code> 文件夹的访问权限，不然安装设置过程中会报错：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> rss</span><br><span class="line">chmod -R 777 ./data</span><br></pre></td></tr></table></figure><p>接下来我们需要设置一下网站的运行目录，因为根据 FreshRSS 官方文档的说明，推荐只将 <code>/p/</code> 目录公开到网络上：</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/04/site_path.jpg!500x" alt="设置运行目录"></p><p>完成后，访问之前创建网站时设置的域名，就可以进入安装设置程序了。</p><p>先设置好语言，检查完毕没有缺少的组件和权限后，如下图所示设置数据库（用户名、数据库名根据之前创建的信息填写）：</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/04/db_settings.jpg!400x" alt="数据库配置"></p><p>之后就是设置好自己的用户名密码，完成安装就可以进入 FreshRSS 界面进行登录操作了。</p><h2 id="2-客户端访问"><a href="#2-客户端访问" class="headerlink" title="2. 客户端访问"></a>2. 客户端访问</h2><p>要通过 Reeder 等客户端来阅读 RSS 资讯，还需要在设置界面等「认证」中打开「允许 API 访问 」，然后前往「用户帐户」设置好「API 密码」。这样，在 Reeder 客户端添加账号时选择 FreshRSS，然后填写如下：</p><ul><li>Sever：设置「API 密码」时右侧显示的链接地址；</li><li>User：FreshRSS 登录用户名；</li><li>Password：刚才设置的「API 密码」。</li></ul><h2 id="3-自动刷新订阅源"><a href="#3-自动刷新订阅源" class="headerlink" title="3. 自动刷新订阅源"></a>3. 自动刷新订阅源</h2><p>根据官方文档推荐的<a href="https://freshrss.github.io/FreshRSS/en/users/03_Main_view.html#refreshing-feeds" target="_blank" rel="noopener">订阅源刷新方案</a>，可以设置 crontab 定时任务如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;5 * * * * php &#x2F;www&#x2F;wwwroot&#x2F;rss&#x2F;app&#x2F;actualize_script.php &gt; &#x2F;tmp&#x2F;FreshRSS.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>其中，<code>/www/wwwroot/rss/</code> 是 FreshRSS 网站的根目录路径，上述任务表示每五分钟刷新一次订阅源。在宝塔面板中设置就很简单，在「计划任务」中添加一个 Shell 脚本定时任务就可以了，脚本内容是：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">php /www/wwwroot/rss/app/actualize_script.php &gt; /tmp/FreshRSS.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>科技树</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器部署 Hexo 博客和看板娘 Live2D API</title>
    <url>//posts/2020/04/15/2020-47-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2%E5%92%8C%E7%9C%8B%E6%9D%BF%E5%A8%98Live2D-API/</url>
    <content><![CDATA[<p>在服务器上部署 Hexo 静态博客有两种方案，一是直接把源代码推送到服务器上，然后在服务器上安装 Node.js 和 hexo-cli，从而直接在服务器上构建网页文件并部署；二是依旧按照之前部署到对象存储的方案，用 GitHub 作为源代码托管，然后用 GitHub Actions 构建网页文件，再同步到服务器的网站根目录下。这里，我选择后一种方案，这样修改的地方比较少，也比较方便。<a id="more"></a></p><h2 id="1-通过-GitHub-Actions-部署-Hexo"><a href="#1-通过-GitHub-Actions-部署-Hexo" class="headerlink" title="1. 通过 GitHub Actions 部署 Hexo"></a>1. 通过 GitHub Actions 部署 Hexo</h2><p>首先，修改原来的 GitHub Actions 脚本，删去部署到阿里云 OSS 的内容，添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">server</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.1.2</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">ARGS:</span> <span class="string">"-avz --delete"</span></span><br><span class="line">    <span class="attr">SOURCE:</span> <span class="string">"public/"</span> <span class="comment"># 要同步到服务器的目录</span></span><br><span class="line">    <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span> <span class="comment"># 配置在服务器上公钥所对应的私钥</span></span><br><span class="line">    <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REMOTE_HOST</span> <span class="string">&#125;&#125;</span> <span class="comment"># 服务器 IP 地址</span></span><br><span class="line">    <span class="attr">REMOTE_PORT:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REMOTE_PORT</span> <span class="string">&#125;&#125;</span> <span class="comment"># SSH 连接端口</span></span><br><span class="line">    <span class="attr">REMOTE_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REMOTE_USER</span> <span class="string">&#125;&#125;</span> <span class="comment"># 服务器 SSH 连接用户名，如 root</span></span><br><span class="line">    <span class="attr">TARGET:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.REMOTE_TARGET</span> <span class="string">&#125;&#125;</span> <span class="comment"># 服务器上对应网站的根目录</span></span><br></pre></td></tr></table></figure><p>对于上述变量，我们直接添加在代码仓库设置的 Secrets 中即可。对于阿里云轻量应用服务器，可以在控制台很容易地生成密钥对，并下载由于连接服务器的私钥（生成后重启一下服务器）。</p><p>设置好 GitHub Actions 各项参数之后，需要在宝塔面板上创建网站，并设置域名等内容，这里就不详细介绍。如果需要 Let’s Encrypt SSL 通配符证书，可能还需要进行 DNS 解析认证，这就需要我们去域名解析提供商那边获取一个可以编辑 DNS 解析记录的 token，方便宝塔面板自动配置解析记录。</p><p>最后，因为 GitHub Actions 同步到服务器网站目录过程中用到了 rsync 这一数据镜像备份工具，所以需要先在服务器上安装好 rsync：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install rsync</span><br></pre></td></tr></table></figure><p><strong>备注</strong>：如果服务器提供商的控制台没有自动配置密钥对的功能，可以在服务器上手动生成。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入用户 SSH 密钥存储目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment"># 列出目录中内容，确认是否已拥有密钥</span></span><br><span class="line">ls</span><br><span class="line"><span class="comment"># 生成 SSH 密钥</span></span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。 如果你不想在使用密钥时输入口令，将其留空即可。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将公钥内容写入 authorized_keys</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 列出私钥的内容</span></span><br><span class="line">cat ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>最后，我们把私钥的内容复制到 GitHub 代码仓库设置的 Secrets 中 <code>SSH_PRIVATE_KEY</code> 变量内即可。</p><h2 id="2-将萌萌哒看板娘抱回家"><a href="#2-将萌萌哒看板娘抱回家" class="headerlink" title="2. 将萌萌哒看板娘抱回家"></a>2. 将萌萌哒看板娘抱回家</h2><p>看板娘的大致设置都可以参考 <a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">stevenjoezhang/live2d-widget</a> 这个项目的介绍。这里我主要记录一下使用上述组件时候，需要调用到的看板娘模型 API 的自建过程。</p><p>首先，在宝塔面板创建新站点，设置好 PHP 版本（不能是纯静态），并添加上 SSL 证书。然后，删去网站根目录 <code>/www/wwwroot/api/</code> 下默认添加创建的所有文件，确保文件夹全部清空。打开 SSH 终端，把 Live2D API 源代码拉取到网站 <code>live2d/</code> 目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/wwwroot/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/fghrsh/live2d_api.git api/live2d</span><br></pre></td></tr></table></figure><p>然后在网站的配置文件中添加代码设置跨域访问：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="variable">$allow_origin</span> always;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET,POST,OPTIONS'</span>;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'Token,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,X_Requested_With,If-Modified-Since,Cache-Control,Content-Type'</span>;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">map</span> <span class="variable">$http_origin</span> <span class="variable">$allow_origin</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> <span class="string">""</span>;</span><br><span class="line">    "~^(https?://localhost(:[0-9]+)?)" $1;</span><br><span class="line">    "~^(https?://127.0.0.1(:[0-9]+)?)" $1; </span><br><span class="line">    "~^(https?://192.168.10.[\d]+(:[0-9]+)?)" $1;</span><br><span class="line">    "~^(https?://local.zdl.one(:[0-9]+)?)" $1;</span><br><span class="line">    "~^https://dlzhang.com" https://dlzhang.com;</span><br><span class="line">    "~^https://blog.dlzhang.com" https://blog.dlzhang.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我的看板娘组件文件都放在了腾讯云的对象存储中并通过其 CDN 进行访问，所以还需要在腾讯云的内容分发网络中对加速域名也设置好允许相关域名跨域访问的权限。</p>]]></content>
      <categories>
        <category>科技树</category>
      </categories>
      <tags>
        <tag>GitHub Actions</tag>
        <tag>服务器</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>升级到 Debian 10 并安装宝塔面板</title>
    <url>//posts/2020/04/15/2020-46-%E5%8D%87%E7%BA%A7%E5%88%B0Debian10%E5%B9%B6%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<p>近日入手了一个阿里云的轻量应用服务器，看着价格还比较实惠，就打算把自己的博客也搬过去。服务器买都买了，当然还要折腾一下其他有趣的应用和服务，比如 RSS 订阅、RSSHub、自动签到、Live2D API 等等<del>（其实是为了部署服务才买了服务器，顺带迁移了博客站点）</del>。所以就在这里记录一下搭建的过程，方便日后维护和重装部署。<a id="more"></a></p><h2 id="1-系统升级到-Debian-10"><a href="#1-系统升级到-Debian-10" class="headerlink" title="1. 系统升级到 Debian 10"></a>1. 系统升级到 Debian 10</h2><p>作为代码小白，当然是无脑选择使用宝塔面板。阿里云的控制台可以直接安装宝塔面板，不过因为搭配的系统是 CentOS，感觉不是很习惯，就直接选择了先安装 Debian 9 系统，然后自行升级的方式。</p><p>作为更新强迫症患者中，当然是要先把系统更新到最新版本啦，这里主要参考了<a href="https://niconiconi.fun/2019/06/14/debian-9-upgrade-debian-10/" target="_blank" rel="noopener">葉子的操作</a>。升级到 Debian 10 （版本代号 buster）之前请确认你没有添加过奇怪的软件源，或者编译过一些未知的东西，如果有的话请了解一下之前的操作会不会对系统造成损伤，如果有的话不建议升级，容易出问题。因此，如果不是全新系统升级，建议先进行备份。</p><p>因为我的是全新系统，就没有备份环节啦。建议先将本地软件更新到最新版，然后再升级 Debian 不然很有可能会出现一些未知的问题，本次升级基于官方源进行。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新软件索引</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 更新本地所有软件到最新版</span></span><br><span class="line">sudo apt full-upgrade</span><br><span class="line"><span class="comment"># 切换 stretch 源到 buster 源</span></span><br><span class="line">sudo sed -i <span class="string">'s/stretch/buster/g'</span> /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 再次更新软件索引</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 升级 Debian 9 stretch 到 Debian 10 buster</span></span><br><span class="line">sudo apt upgrade</span><br><span class="line"><span class="comment"># 重启服务器</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>由于是跨版本升级，在第五个命令的升级过程中很多地方需要我们手动设置或确认：</p><ul><li><p>首先需要确认的是 apt， 感兴趣的可以看一下具体参数设置，直接输入 <code>q</code> 进行安装；</p></li><li><p>之后可能会跳出 Configuring kexec-tools，Configuring kdump-tools 和 Configuring libc6:amd64 的确认窗口，这里选择 <code>&lt;Yes&gt;</code>；</p></li><li><p>接下来就和平时更新差不多了，遇到冲突选择 <code>Y or I</code> 使用更新配置，还是 选择 <code>N or O</code> 保留已有配置，或者其他选项。我个人因为是全新安装升级，所以都选择了 <code>Y</code> 使用更新配置。</p></li></ul><h2 id="2-安装宝塔面板"><a href="#2-安装宝塔面板" class="headerlink" title="2. 安装宝塔面板"></a>2. 安装宝塔面板</h2><p>参考宝塔官网给出的安装命令安装宝塔面板：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -sSO http://download.bt.cn/install/install_panel.sh &amp;&amp; bash install_panel.sh</span><br></pre></td></tr></table></figure><p>安装完毕后就会显示面板的访问路径、默认的登录用户名密码等信息。这里需要注意的是，我们需要先去云服务器的控制台安全组（防火墙）处先把宝塔面板访问的默认端口 8888 放通，要不然是无法访问面板的。</p><p>在浏览器登录宝塔面板后，就会跳出推荐安装套件的窗口。选择 LNMP 套件极速安装，版本上因为我的机器内存只有 1G，所以就选择了 MySQL 5.5 的版本，其他都选择了最新版本。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/04/LNMP.jpg!500x" alt="推荐安装套件"></p><div class="note info"><p><strong>注意</strong>：如果发现下载时无法连接到宝塔的下载地址（特别是境外服务器），可能需要先在首页的「Linux 工具箱」中临时修改一下「DNS 设置」，例如使用 1.1.1.1 或者 8.8.8.8。</p></div><p>安装完推荐套件后，继续在「软件商店」中安装其他需要的软件，我们这里选择安装：</p><ul><li>[运行环境] Docker 管理器：方便后续安装 RSSHub 和自动签到服务；</li><li>[运行环境] PM2 管理器：Nodejs 服务可以通过其管理，如果安装 Nodejs 失败，可以使用 <code>nvm</code> 手动安装，方法参考 <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm-sh/nvm</a> 的说明，可能需要指定好路径才能正确使用（具体可以参考 <a href="https://www.cnblogs.com/weifeng1463/p/11321432.html" target="_blank" rel="noopener">解决 nvm command not found 问题的方法</a>）；</li><li>[系统工具] 日志清理工具：可以一键清理指定日志和系统垃圾；</li><li>[插件] 阿里云 OSS：将网站或数据库打包备份到阿里云 OSS 对象存储空间，在阿里云同一地域下的云产品之间还可以通过内网地址连接，既能提高连接速度，也能减少流量费用；</li><li>[第三方应用] Nginx 免费防火墙。</li></ul><p>不过，安装完毕设置阿里云 OSS 参数插件之前，执行以下命令，不然可能无法正常执行备份操作（提示：<code>ImportError: No module named oss2</code>）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install oss2</span><br></pre></td></tr></table></figure><p>对于 PHP，我们可以在「性能调整」中根据自己的内存大小修改并发方案，还可以选择安装以下扩展：</p><ul><li>fileinfo：FreshRSS 需要此扩展</li><li>opcache：开启脚本缓存可以提高 PHP 运行性能</li><li>redis：内容缓存</li></ul><div class="note info"><p><strong>注意</strong>：内存只有 1G 的服务器可能无法安装 fileinfo，这时候需要我们在「Linux 工具箱」的「Swap/虚拟内存」中添加 Swap，我们可以设置如 1024MB 或者 1500MB。</p></div><p>软件安装完毕后，可以进入「面板设置」，修改默认的访问端口、登录用户名密码等信息，还可以为面板绑定访问域名并添加 SSL 证书。</p><p>对于 FTP 工具，本地可以使用 FileZilla 软件，使用方法可以参考宝塔面板的<a href="https://www.bt.cn/bbs/thread-43162-1-1.html" target="_blank" rel="noopener">论坛帖子</a>。</p>]]></content>
      <categories>
        <category>科技树</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>宝塔面板</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔面板部署 RSSHub 和自动签到 Docker 应用</title>
    <url>//posts/2020/04/15/2020-49-%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%83%A8%E7%BD%B2RSSHub%E5%92%8C%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0Docker%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>使用宝塔面板下部署 Docker 应用还是挺容易的，首先需要安装 Docker 管理器。不过这个管理器在 Safari 浏览器中似乎有 bug，无法进行点击操作，但是在 Chrome 浏览器中可以正常操作。本文将通过这个 Docker 管理器来安装 RSSHub 这一 RSS 生成器和一个自动签到应用。<a id="more"></a></p><h2 id="1-RSSHub：万物皆可-RSS"><a href="#1-RSSHub：万物皆可-RSS" class="headerlink" title="1. RSSHub：万物皆可 RSS"></a>1. RSSHub：万物皆可 RSS</h2><p>因为有些网站或者媒体没有主动提供 RSS 订阅链接，所以我们就可以依靠 RSSHub 这一个开源、简单易用、易于扩展的 RSS 生成器，给任何奇奇怪怪的内容生成 RSS 订阅源。</p><h3 id="1-1-Docker-部署"><a href="#1-1-Docker-部署" class="headerlink" title="1.1 Docker 部署"></a>1.1 Docker 部署</h3><p>首先，打开 Docker 管理器，在「镜像管理」中获取官方库镜像 <code>diygod/rsshub</code>。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/04/docker_mirror.jpg!500x" alt="获取镜像"></p><p>然后，在「容器列表」创建新的 Docker 容器：</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/04/rsshub_docker.jpg!400x" alt="创建 RSSHub 容器"></p><p>这里我们设置了：</p><ul><li>容器端口 1200 映射到服务器端口 1200；</li><li>服务器目录 <code>/www/wwwroot/rsshub/</code> 可以读写容器目录 <code>/usr/src/app/</code>；</li><li>CPU 权重改为 30。</li></ul><p>然后，我们创建一个新的网站，不需要创建新的数据库，PHP 设置为纯静态。把文章根目录下的文件都清空，然后把 RSSHub 源代码拉取到网站根目录 <code>/www/wwwroot/rsshub/</code>。这样的目的是以后有需要，可以直接修改该目录下的文件，而不需要进入 Docker 容器进行修改。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/wwwroot/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/diygod/rsshub.git rsshub</span><br></pre></td></tr></table></figure><p>最后，设置反向代理，以便我们可以通过域名来访问该服务：</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/04/reverse_proxy.jpg!500x" alt="反向代理"></p><p>这样，我们的 RSSHub 就完成了搭建，具体的配置和路由可以参见 <a href="https://docs.rsshub.app" target="_blank" rel="noopener">RSSHub 文档</a>。</p><h3 id="1-2-Docker-Compose-部署"><a href="#1-2-Docker-Compose-部署" class="headerlink" title="1.2 Docker Compose 部署"></a>1.2 Docker Compose 部署</h3><p>当然，我们也可以通过 Docker Compose 部署 RSSHub，部署步骤很简单，直接参考 RSSHub 文章介绍即可。部署完毕后也会显示在上面提及的 Docker 管理器中。</p><p>当然首先需要先安装 Docker Compose，参照<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">文档说明</a>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 Docker Compose 稳定发布版</span></span><br><span class="line">sudo curl -L "https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置访问权限</span></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看安装版本</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>接下来安装RSSHub：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 docker-compose.yml</span></span><br><span class="line">wget https://raw.githubusercontent.com/DIYgod/RSSHub/master/docker-compose.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 volume 持久化 Redis 缓存</span></span><br><span class="line">docker volume create redis-data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 Docker</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新：先执行以下命令删除旧容器，然后重复上述安装步骤</span></span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>如果要添加配置，可以修改 <a href="https://github.com/DIYgod/RSSHub/blob/master/docker-compose.yml" target="_blank" rel="noopener">docker-compose.yml</a> 中的 <code>environment</code> 进行配置。</p><h2 id="2-自动签到应用"><a href="#2-自动签到应用" class="headerlink" title="2. 自动签到应用"></a>2. 自动签到应用</h2><p><a href="https://qiandao.today" target="_blank" rel="noopener">qiandao.today</a> 这个网站提供了自动签到的服务，上面提供了许多网站自动签到的模板。我们也可以利用公开的源代码自己搭建一个这样的自动签到应用。</p><h3 id="2-1-部署容器"><a href="#2-1-部署容器" class="headerlink" title="2.1 部署容器"></a>2.1 部署容器</h3><p>这里采用 Docker Compose 部署的方法，比较方便快捷。首先创建一个 <code>docker-compose.yml</code>（目录任意，为方便管理可以放在站点的目录下）：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">qiandao:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">fangzhengjin/qiandao</span> <span class="comment">#容器镜像</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">qiandao</span> <span class="comment">#设置容器名称</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span> <span class="comment">#表示重启 docker 后自动重启该容器</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">'1300:80'</span> <span class="comment">#表示容器的 80 端口映射到服务器的 1300 端口</span></span><br></pre></td></tr></table></figure><p>该目录下执行以下命令可以：启动、停止、移除容器。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止（不需要在该目录下执行）</span></span><br><span class="line">docker stop qiandao</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除</span></span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>接下来我们按照前面介绍的方法设置反向代理，这样就可以访问之前设置的域名注册账号，再把该账号设置为管理员：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入容器管理（也可通过宝塔面板 Docker 管理器进入）</span></span><br><span class="line">docker exec -it qiandao /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置站点管理员（邮箱需要已注册）</span></span><br><span class="line">python ./chrole.py admin@example.com admin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器管理</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="2-2-获取-Cookies"><a href="#2-2-获取-Cookies" class="headerlink" title="2.2 获取 Cookies"></a>2.2 获取 Cookies</h3><p>签到模板可以从 <a href="https://qiandao.today" target="_blank" rel="noopener">qiandao.today</a> 下载，具体使用方法可以查阅官方文档。对于需要获取 Cookies 进行签到的网站，我们可以安装 Chrome 扩展应用 <a href="https://chrome.google.com/webstore/detail/cookies-get-assistant/ljjpkibacifkfolehlgaolibbnlapkme" target="_blank" rel="noopener">GetCookies</a>。但是，这里下载安装的只限用于 qiandao.today 这个网站。如果我们要在自己搭建的签到网站获取 Cookies，可以：</p><ul><li>从 GitHub 下载<a href="https://github.com/acgotaku/GetCookies" target="_blank" rel="noopener">该项目的源代码</a>；</li><li>全局搜索 <code>qiandao.today</code>，替换为自己的签到网站域名并保存；</li><li>在 Chrome 浏览器的扩展程序管理页面（chrome://extensions），选择「加载已解压的扩展程序」，将刚才已经编辑过的扩展程序文件夹上传安装即可。</li></ul><h3 id="2-3-配置与备份数据"><a href="#2-3-配置与备份数据" class="headerlink" title="2.3 配置与备份数据"></a>2.3 配置与备份数据</h3><p>如果不希望别人访问我们的签到网站注册账号，可以把 <code>/web/handlers/login.py</code> 文件第 66-130 行的代码注释掉（前后均写上 <code>&#39;&#39;&#39;</code>）。编辑好该文件后，在该文件目录执行以下命令把文件复制到容器内：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把文件复制到容器内</span></span><br><span class="line">docker cp login.py qiandao:/usr/src/app/web/handlers/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启容器</span></span><br><span class="line">docker restart qiandao</span><br></pre></td></tr></table></figure><p>要备份我们的数据信息，可以执行如下命令，建议恢复数据库后立即重启容器（方法同上）。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将容器中的数据库文件复制到当前目录</span></span><br><span class="line">docker cp qiandao:/usr/src/app/database.db .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将备份的数据库复制到容器中（当前目录的 database.db 文件）</span></span><br><span class="line">docker cp database.db qiandao:/usr/src/app/</span><br></pre></td></tr></table></figure><p>调整相关配置，可以修改 <code>config.py</code> 文件，复制到容器方法和备份数据库文件到方法一样。</p>]]></content>
      <categories>
        <category>科技树</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>RSS</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>博客迁移到 Typecho 记录</title>
    <url>//posts/2020/04/30/2020-50-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0Typecho%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>拥有一台自己的服务器之后就想着要搞一个动态博客了，毕竟有后台管理会方便很多。看到 Typecho 原生支持 Markdown，而且有一个很漂亮、功能强大的主题 Handsome，就决定将我的 Hexo 博客迁移到 Typecho Handsome 了。目前基本上完成了配置、美化、速度优化等工作。<a id="more"></a></p><h2 id="1-Typecho-的个性化"><a href="#1-Typecho-的个性化" class="headerlink" title="1. Typecho 的个性化"></a>1. Typecho 的个性化</h2><h3 id="1-1-自定义样式"><a href="#1-1-自定义样式" class="headerlink" title="1.1 自定义样式"></a>1.1 自定义样式</h3><p>主要的自定义工作我都通过加入自定义 CSS 和 JS 文件来完成了，具体代码可以参考我的 GitHub 项目 <a href="https://github.com/lei2rock/Typecho-Assets" target="_blank" rel="noopener">Typecho-Assets</a> 和 <a href="https://github.com/lei2rock/Typecho-Plugin-BanbanStyle" target="_blank" rel="noopener">BanbanStyle 插件</a>。其中包含了比如随机彩色标签云、中英文字符件自动添加空格（pangu.js）、macOS 风格代码框、今日诗词、看板娘组件等等。</p><p>有几个样式或功能还需要一点点额外的配置：</p><ul><li><strong>删除首页中间标题</strong>：<code>/usr/themes/handsome/index.php</code> 删除以下代码</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;h1 class="m-n font-thin text-black l-h"&gt;&lt;?php $this-&gt;options-&gt;title(); ?&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>添加今日诗词布局</strong>（需要配合 JS 文件加载今日诗词 SDK）：在上述标签下方找到以下代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">'加载中……'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  $.ajax(&#123;</span></span><br><span class="line"><span class="string">    type: \'Get\',</span></span><br><span class="line"><span class="string">    url: \'https://v1.hitokoto.cn/\',</span></span><br><span class="line"><span class="string">    success: function(data) &#123;</span></span><br><span class="line"><span class="string">      var hitokoto = data.hitokoto;</span></span><br><span class="line"><span class="string">      $(\'.indexWords\').text(hitokoto);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;'</span>;</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">'</span></span><br><span class="line"><span class="string">&lt;div class="poem-wrap"&gt;</span></span><br><span class="line"><span class="string">  &lt;span id="poem_sentence"&gt;正在加载今日诗词....&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;'</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>文章结尾显示标签</strong>：<code>/usr/themes/handsomepost.php</code> 打赏模块结尾添加以下代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--生成当前文章标签--&gt;</span><br><span class="line">&lt;div id="tag_cloud-2" class="post-tags tags l-h-2x" style="text-align:center;margin-top:5px;"&gt;</span><br><span class="line">  &lt;style&gt;.post-tags a&#123;font-size:<span class="number">12</span>px!important;color:<span class="comment">#fff!important;&#125;&lt;/style&gt;</span></span><br><span class="line">  <span class="meta">&lt;?php</span> <span class="keyword">$this</span>-&gt;tags(<span class="string">' '</span>, <span class="keyword">true</span>, <span class="string">'暂无标签'</span>); <span class="meta">?&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>页脚更改</strong>：<code>/usr/themes/handsome/component/footer.php</code> 第 5-13 行代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;div class="wrapper bg-light"&gt;</span><br><span class="line">  &lt;span class="pull-right hidden-xs text-ellipsis"&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span> <span class="keyword">$this</span>-&gt;options-&gt;BottomInfo(); <span class="meta">?&gt;</span></span><br><span class="line">    Powered by &lt;a target=<span class="string">"_blank"</span> href=<span class="string">"http://www.typecho.org"</span>&gt;Typecho&lt;/a&gt;&amp;nbsp;|&amp;nbsp;Theme by &lt;a target=<span class="string">"_blank"</span></span><br><span class="line"> href=<span class="string">"https://www.ihewro.com/archives/489/"</span>&gt;handsome&lt;/a&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">  &lt;span class="text-ellipsis"&gt;</span><br><span class="line">    &amp;copy;&amp;nbsp;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> date(<span class="string">"Y"</span>);<span class="meta">?&gt;</span> Copyright&amp;nbsp;</span><br><span class="line">    <span class="meta">&lt;?php</span> <span class="keyword">$this</span>-&gt;options-&gt;BottomleftInfo(); <span class="meta">?&gt;</span></span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;div class="wrapper bg-light"&gt;</span><br><span class="line">  &lt;span class="pull-right hidden-xs text-ellipsis"&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span> <span class="keyword">$this</span>-&gt;options-&gt;BottomInfo(); <span class="meta">?&gt;</span></span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">  &lt;span class="text-ellipsis"&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span> <span class="keyword">$this</span>-&gt;options-&gt;BottomleftInfo(); <span class="meta">?&gt;</span></span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后就可以直接在主题的「开发者设置」里添加需要的内容了，不会受到原本页脚内容的局限。</p><ul><li><strong>自定义翻译</strong>：修改 <code>/usr/themes/handsome/lang/</code> 文件夹的内容。</li></ul><h3 id="1-2-PJAX-回调函数"><a href="#1-2-PJAX-回调函数" class="headerlink" title="1.2 PJAX 回调函数"></a>1.2 PJAX 回调函数</h3><p>如果开启了 PJAX，一些每次刷新页面都要执行的脚本需要加入回调。目前我根据自定义的 JS 文件设置了以下回调函数。其中最后一条是因为开启了图片延迟加载后，相册页缩略图无法显示。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pangu.js</span></span><br><span class="line">pangu.spacingPage();</span><br><span class="line"></span><br><span class="line"><span class="comment">// colorful tag cloud</span></span><br><span class="line">colorful_tags();</span><br><span class="line"></span><br><span class="line"><span class="comment">// macOS 代码框</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> Prism !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    Prism.highlightAll(<span class="literal">true</span>,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 今日诗词</span></span><br><span class="line"><span class="keyword">if</span> ($(<span class="string">"div"</span>).hasClass(<span class="string">"poem-wrap"</span>)) &#123;</span><br><span class="line">    get_poem()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相册缩略图</span></span><br><span class="line">$(<span class="string">".album-thumb img"</span>).lazyload(&#123;</span><br><span class="line">    effect: <span class="string">"fadeIn"</span>,</span><br><span class="line">    threshold: <span class="string">"200"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-3-FancyBox-缩略图"><a href="#1-3-FancyBox-缩略图" class="headerlink" title="1.3 FancyBox 缩略图"></a>1.3 FancyBox 缩略图</h3><p>就如在用 Hexo 时候进行的修改一样，我希望在使用 FancyBox 时候预览的缩略图是小图，点开后可以加载原图，这样就需要修改 <code>/usr/themes/handsome/assets/js/core.min.js</code> 文件。因为是经过压缩后的版本，所以先恢复回有缩进的版本，然后修改 <code>seFancyBox</code> 函数的定义。</p><p>找到 <code>seFancyBox</code> 函数最后一句：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">j += i, <span class="string">"undefined"</span> !== f ? b.prop(<span class="string">"outerHTML"</span>, <span class="string">'&lt;a class="light-link img-blur" data-fancybox="gallery" style="background-image: url('</span> + g + <span class="string">')" no-pjax data-type="image" data-caption="'</span> + c + <span class="string">'" href="'</span> + g + <span class="string">'"&gt;'</span> + j + <span class="string">"&lt;/a&gt;"</span>) : b.prop(<span class="string">"outerHTML"</span>, <span class="string">'&lt;a class="light-link" data-fancybox="gallery" no-pjax data-type="image" data-caption="'</span> + c + <span class="string">'" href="'</span> + g + <span class="string">'"&gt;'</span> + j + <span class="string">"&lt;/a&gt;"</span>)</span><br></pre></td></tr></table></figure><p>在这一句之前添加（以适配我自己设置的腾讯云对象存储剪裁后缀，如 <code>!500x</code>）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">g = g.replace(<span class="regexp">/![0-9]&#123;3,&#125;x/</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>然后再对 <code>core.min.js</code> 文件进行压缩保存即可。</p><h2 id="2-Valine-评论迁移到-Typecho"><a href="#2-Valine-评论迁移到-Typecho" class="headerlink" title="2. Valine 评论迁移到 Typecho"></a>2. Valine 评论迁移到 Typecho</h2><p>之前是使用 Valine 搭配 LeanCloud 的评论系统，要迁移到 Typecho 还是蛮复杂的，毕竟没有现成的工具，而且评论的 id 和文章的 id 与 Typecho 格式也不一致。目前是参考一个 <a href="https://veltlion.github.io/valine-to-wxr/" target="_blank" rel="noopener">Valine 转 Wordpress 评论的脚本</a>，自己修改了代码。脚本需要先安装 <code>jq</code> 这个 JSON 文件处理包，然后可以实现 JSON 转为 SQL 文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># by @lei2rock</span></span><br><span class="line"><span class="comment"># Valine to Typecho</span></span><br><span class="line"><span class="comment"># 2020-04-22</span></span><br><span class="line"></span><br><span class="line">comfile=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line">line=$(grep comment <span class="variable">$comfile</span> |wc -l)</span><br><span class="line">author_mail=<span class="string">"这里填写自己的邮箱地址"</span></span><br><span class="line">author_url=<span class="string">"这里填写自己的博客链接"</span></span><br><span class="line"><span class="comment">#author_ip="这里填写自己的ip"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">comment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> ((i=0; i&lt;<span class="variable">$line</span>; i++)); <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">let</span> j=<span class="variable">$i</span>+1</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"第 <span class="variable">$j</span> 条评论\n"</span></span><br><span class="line">        coid=$(jq -r <span class="string">".results[<span class="variable">$i</span>].objectId"</span> <span class="variable">$comfile</span>)</span><br><span class="line">        cid=$(jq -r <span class="string">".results[<span class="variable">$i</span>].url"</span> <span class="variable">$comfile</span>)</span><br><span class="line">        cid=<span class="string">'['</span><span class="variable">$cid</span><span class="string">']'</span></span><br><span class="line">        author=$(jq -r <span class="string">".results[<span class="variable">$i</span>].nick"</span> <span class="variable">$comfile</span>)</span><br><span class="line">        mail=$(jq -r <span class="string">".results[<span class="variable">$i</span>].mail"</span> <span class="variable">$comfile</span>)</span><br><span class="line">        url=$(jq -r <span class="string">".results[<span class="variable">$i</span>].link"</span> <span class="variable">$comfile</span> | sed <span class="string">'s/^null$//'</span>)</span><br><span class="line">        ip=$(jq -r <span class="string">".results[<span class="variable">$i</span>].ip"</span> <span class="variable">$comfile</span> | sed <span class="string">'s/^null$//'</span>)</span><br><span class="line">        dateYMD=$(jq -r <span class="string">".results[<span class="variable">$i</span>].createdAt"</span> <span class="variable">$comfile</span> | sed <span class="string">'s/T/ /; s/\.[0-9]\&#123;3\&#125;Z//'</span>)</span><br><span class="line">        date=$(date -d <span class="string">"<span class="variable">$dateYMD</span>"</span> +%s)</span><br><span class="line">        parent=$(jq -r <span class="string">".results[<span class="variable">$i</span>].rid"</span> <span class="variable">$comfile</span> | sed <span class="string">'s/^null$/0/'</span>)</span><br><span class="line">        text=$(jq -r <span class="string">".results[<span class="variable">$i</span>].comment"</span> <span class="variable">$comfile</span>)</span><br><span class="line">        agent=$(jq -r <span class="string">".results[<span class="variable">$i</span>].ua"</span> <span class="variable">$comfile</span>)</span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$mail</span> == <span class="variable">$author_mail</span> ]]; <span class="keyword">then</span></span><br><span class="line">            authorId=1</span><br><span class="line">            ownerId=1</span><br><span class="line">            url=<span class="variable">$author_url</span></span><br><span class="line"><span class="comment">#           ip=$author_ip</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            authorId=0</span><br><span class="line">            ownerId=0</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$j</span> == <span class="variable">$line</span> ]]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span>  <span class="string">"(<span class="variable">$coid</span>, "</span><span class="string">"'"</span><span class="string">"<span class="variable">$cid</span>"</span><span class="string">"'"</span><span class="string">", <span class="variable">$date</span>, "</span><span class="string">"'"</span><span class="string">"<span class="variable">$author</span>"</span><span class="string">"'"</span><span class="string">", <span class="variable">$authorId</span>, <span class="variable">$ownerId</span>, "</span><span class="string">"'"</span><span class="string">"<span class="variable">$mail</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"<span class="variable">$url</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"<span class="variable">$ip</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"<span class="variable">$agent</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"<span class="variable">$text</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"comment"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"approved"</span><span class="string">"'"</span><span class="string">", <span class="variable">$parent</span>);"</span>&gt;&gt;<span class="variable">$comfile</span>.sql</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span>  <span class="string">"(<span class="variable">$coid</span>, "</span><span class="string">"'"</span><span class="string">"<span class="variable">$cid</span>"</span><span class="string">"'"</span><span class="string">", <span class="variable">$date</span>, "</span><span class="string">"'"</span><span class="string">"<span class="variable">$author</span>"</span><span class="string">"'"</span><span class="string">", <span class="variable">$authorId</span>, <span class="variable">$ownerId</span>, "</span><span class="string">"'"</span><span class="string">"<span class="variable">$mail</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"<span class="variable">$url</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"<span class="variable">$ip</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"<span class="variable">$agent</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"<span class="variable">$text</span>"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"comment"</span><span class="string">"'"</span><span class="string">", "</span><span class="string">"'"</span><span class="string">"approved"</span><span class="string">"'"</span><span class="string">", <span class="variable">$parent</span>),"</span>&gt;&gt;<span class="variable">$comfile</span>.sql</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">touch <span class="variable">$comfile</span>.sql</span><br><span class="line"><span class="built_in">echo</span>  <span class="string">"INSERT INTO \`typecho_comments\` (\`coid\`, \`cid\`, \`created\`, \`author\`, \`authorId\`, \`ownerId\`, \`mail\`, \`url\`, \`ip\`, \`agent\`, \`text\`, \`type\`, \`status\`, \`parent\`) VALUES"</span>&gt;&gt;<span class="variable">$comfile</span>.sql</span><br><span class="line">comment</span><br><span class="line"><span class="built_in">echo</span> <span class="keyword">done</span>!</span><br></pre></td></tr></table></figure><p>保存该文件命名为 <code>valine2typecho.sh</code>，重命名 LeanCloud 导出的 Valine 评论文件为 <code>comment.json</code>，然后在这两个文件所在目录执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh valine2typecho.sh comment.json</span><br></pre></td></tr></table></figure><p>之后可能需要一些手工调整（所以评论数少的话可以用）：例如调整评论的 <code>coid</code>、文章的 <code>cid</code>，修正一些 SQL 可能不支持的格式（比如部分字符要转义），一些 html 标签要在后台评论设置中添加支持，修改部分评论的 <code>parent</code> 值以匹配相应上级评论等等，具体可以参考 MySQL 导出的数据库文件格式。</p><p>导入评论后文章统计的评论数量可能不准确，可以先备份数据库，然后数据库中执行以下语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> typecho_contents t1 <span class="keyword">SET</span> t1.commentsNum = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> typecho_comments t2 <span class="keyword">where</span> t2.cid = t1.cid)</span><br></pre></td></tr></table></figure><h2 id="3-插件介绍"><a href="#3-插件介绍" class="headerlink" title="3. 插件介绍"></a>3. 插件介绍</h2><p>介绍一下自己在用的插件，也推荐了一些其他不错的插件，都是在 GitHub 上开源免费的插件。</p><h3 id="3-1-在使用的插件"><a href="#3-1-在使用的插件" class="headerlink" title="3.1 在使用的插件"></a>3.1 在使用的插件</h3><table><thead><tr><th>插件</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://github.com/lei2rock/Typecho-Plugin-BanbanStyle" target="_blank" rel="noopener">BanbanStyle</a></td><td>为我自己的博客设置而开发的插件，功能见 GitHub 项目介绍</td></tr><tr><td><a href="https://github.com/JoyChou93/CommentToMail" target="_blank" rel="noopener">CommentToMail</a></td><td>评论邮件通知，可以参考我的邮件模板：<a href="https://github.com/lei2rock/Typecho-Assets/plugins/CommentToMail/owner.html" target="_blank" rel="noopener">通知博主</a>、<a href="https://github.com/lei2rock/Typecho-Assets/plugins/CommentToMail/guest.html" target="_blank" rel="noopener">通知访客</a></td></tr><tr><td>Handsome</td><td>Handsome 主题配套插件</td></tr><tr><td><a href="https://github.com/bayunjiang/typecho-sitemap" target="_blank" rel="noopener">Sitemap</a></td><td>自动生成网站地图</td></tr><tr><td><a href="https://github.com/dishcheng/cosUploadV5" target="_blank" rel="noopener">cosUploadV5</a></td><td>上传文件、图片到腾讯云对象存储并提供链接</td></tr><tr><td><a href="https://github.com/lei2rock/Typecho-Plugin-MemorialDay" target="_blank" rel="noopener">MemorialDay</a></td><td>自己开发的哀悼日开启全站黑白滤镜</td></tr></tbody></table><h3 id="3-2-其他推荐的插件"><a href="#3-2-其他推荐的插件" class="headerlink" title="3.2 其他推荐的插件"></a>3.2 其他推荐的插件</h3><table><thead><tr><th>插件</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://github.com/YianAndCode/Comment2Wechat" target="_blank" rel="noopener">Comment2Wechat</a></td><td>评论推送至微信，依托 Server 酱实现</td></tr><tr><td><a href="https://github.com/MoeLoli/Comment2Telegram" target="_blank" rel="noopener">Comment2Telegram</a></td><td>评论推送至 Telegram，支持回复评论、通过评论、垃圾评论和删除评论</td></tr><tr><td><a href="https://github.com/lei2rock/Typecho-Plugin-macOScode" target="_blank" rel="noopener">macOScode</a></td><td>自己开发的实现 macOS 风格代码框，应该只适配 Handsome 主题</td></tr><tr><td><a href="https://github.com/DT27/EditorMD" target="_blank" rel="noopener">EditorMD</a></td><td>比原生更好用的 Markdown 编辑器（可以只使用编辑器功能）</td></tr></tbody></table><h2 id="4-Handsome-主题时光机"><a href="#4-Handsome-主题时光机" class="headerlink" title="4. Handsome 主题时光机"></a>4. Handsome 主题时光机</h2><p>Handsome 主题内置了一个「时光机」功能，可以类似微博、微信朋友圈一样发布动态，而且支持通过微信公众号、Chrome 插件等多平台发布。同时，还可以在该页面上利用 RSS 订阅源把自己的微博和 Twitter 等平台的动态同步显示。</p><h3 id="4-1-多平台发布动态"><a href="#4-1-多平台发布动态" class="headerlink" title="4.1 多平台发布动态"></a>4.1 多平台发布动态</h3><p>Handsome 开发者提供了一个微信公众号发布的渠道，但是这样需要用到别人的服务，而且后期如果要添加新的网站等都需要在该平台修改，不是很方便。既然有自己的服务器，还有自己的微信公众号，那就不如自己搭建一个。</p><ol><li><p>首先下载 <a href="https://github.com/iLay1678/wechat_for_handsome" target="_blank" rel="noopener">wechat_for_handsome</a> 项目到自己服务器目录，我们可以添加一个新的网站和域名来部署，同时需要创建一个对应的数据库。</p></li><li><p>在安装该服务前，我们需要先去微信公众号后台获取必要的设置参数。在微信公众号后台「开发-基本配置」处获取 AppID 和 AppSecret。然后我们参照微信公众号的<a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html" target="_blank" rel="noopener">文档</a>，使用刚才获得的两个参数在 <a href="https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&type=基础支持&form=获取access_token接口%20/token" target="_blank" rel="noopener">微信公众平台接口调试工具</a> 获取 <code>access_token</code>。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/04/wechat-channel-server.jpg!600x" alt="服务器配置"></p></li><li><p>接下来回到微信公众号后台「开发-基本配置」处启用服务器配置。服务器地址（URL）填写为「项目域名/server.php」；令牌（Token）就是第二步得到的 <code>access_token</code>；消息加解密密钥（EncodingAESKey）可以随机生成但是一定要记录，因为我们还需要在项目安装时候填写；消息加解密方式可以选择「安全模式」。因为还没有在服务器上安装，所以先不要提交，放一边，进入下一步。</p></li><li><p>回到之前添加的站点，访问「项目域名/install.php」进入安装步骤。依次输入要求的几个参数，这些我们都通过上面的几个步骤获得了，设置完毕后安装即可。这样就可以回到第三步的公众号服务器配置，提交验证。</p></li><li><p>然后向公众号发送「绑定」，点击链接填写相关信息进行绑定，绑定完毕就可以参考主题文档的说明发布动态了。如果没有反应，可能是刚刚验证完毕，稍微等一会儿就好。其中，时光机的 <code>cid</code> 可以在后台独立页面管理处获得，验证编码可以在主题设置处自行设置一个当作访问密码。</p></li><li><p>如果公众号启用了「服务器配置」后，自定义的菜单不见了，可以在功能插件设置处重新启用即可。Chrome 扩展发布动态的方法可以直接参考主题文档配置。</p></li></ol><h3 id="4-2-添加-RSS-订阅源"><a href="#4-2-添加-RSS-订阅源" class="headerlink" title="4.2 添加 RSS 订阅源"></a>4.2 添加 RSS 订阅源</h3><p>时光机上要显示自己的微博或者 Twitter 的动态，可以借助 RSSHub 生成的订阅源。RSSHub 的部署可以参考我之前的文章，其中 Twitter 还需要去申请获得 API 相应的 key 才可以访问。</p><p>当然，使用的时候不能直接填写这个订阅源，因为会被禁止跨域访问，这时候可以在该订阅源链接前面加上 <code>https://cors-anywhere.herokuapp.com/</code>。例如我们要订阅微博的 RSS 订阅源链接是 <code>https://rsshub.app/weibo/user/{weibo_user_id}</code>，那么为了方便跨域访问，可以在时光机设置时候填写:</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">https://cors-anywhere.herokuapp.com/https://rsshub.app/weibo/user/&#123;weibo_user_id&#125;</span></span><br></pre></td></tr></table></figure><p>当然，可能通过访问 herokuapp.com 来获取订阅源速度比较慢，那就可以自行部署这个 <a href="https://github.com/Rob--W/cors-anywhere" target="_blank" rel="noopener">CORS Anywhere 服务</a>。方法也很简单，以使用宝塔面板为例，因为部署该项目使用的是 Nodejs 环境，需要先安装 Nodejs，方法可以参考我之前的文章。</p><p>然后下载上述项目源码到需要部署的服务器目录，项目根目录下创建环境变量设置文件 <code>.env</code>，编辑文件添加环境变量（具体含义用法见该项目文档），例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT &#x3D; 1400</span><br><span class="line">CORSANYWHERE_WHITELIST &#x3D; https:&#x2F;&#x2F;blog.dlzhang.com,https:&#x2F;&#x2F;rss.zdl.one</span><br></pre></td></tr></table></figure><p>之后安装所需要的依赖（以下命令二选一）:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yarn 安装方式</span></span><br><span class="line">yarn</span><br><span class="line">yarn add dotenv # 调用环境变量文件需要的依赖</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> npm 安装方式</span></span><br><span class="line">npm install</span><br><span class="line">npm install dotenv --save # 调用环境变量文件需要的依赖</span><br></pre></td></tr></table></figure><p>修改启动文件 <code>server.js</code>，在最开头加入以下内容，以便在最开始就引入环境变量文件的参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Import .env</span></span><br><span class="line"><span class="keyword">let</span> dotenv = <span class="built_in">require</span>(<span class="string">'dotenv'</span>);</span><br><span class="line">dotenv.config(<span class="string">'./env'</span>);</span><br></pre></td></tr></table></figure><p>可以手动启动，或者用「PM2 管理器」启动，选择启动文件为 <code>server.js</code> 即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure><p>最后，为服务设置反向代理，使得可以通过域名访问该服务。</p><h2 id="5-访问速度与安全"><a href="#5-访问速度与安全" class="headerlink" title="5. 访问速度与安全"></a>5. 访问速度与安全</h2><h3 id="5-1-CDN"><a href="#5-1-CDN" class="headerlink" title="5.1 CDN"></a>5.1 CDN</h3><p>最开始是静态资源走腾讯云境内 CDN（存储在对象存储中），毕竟腾讯云每个月有 10G 免费境内 CDN 流量包可以使用。但是测试和实际使用发现，如果只是使用境内 CDN 分发静态资源，海外访问的时候会有「云减速」的效果，但是如果开启全球加速，海外访问的流量费也是一笔钱。</p><p>而如果选择 Cloudflare 的 CDN，似乎对境内访问有「云减速」的效果。如果是 DNS 双线解析，境内直接访问服务器，境外访问 Cloudflare 的 CDN（可以通过 Cloudflare Partner 面板实现 CNAME 接入）， 可以让海外访问走 CDN，不过感觉对境内一样是源站访问的话用 CDN 意义不算很大。而且，因为目前服务器和我同地域，访问延迟特别低，体验很好，加上 Cloudflare 的 CDN，纵使是境外也感觉有「云减速」的效果，似乎没有给我选择最近的节点或者是回源获取资源了吧。</p><p>反正经过几番尝试，最后还是只选择了主题的静态文件直接放到 GitHub，借助 jsDelivr 的 CDN 进行分发。自定义的静态文件也放到了 GitHub，但主要是版本控制的目的，毕竟 jsDelivr 的 CDN 缓存刷新速度不是那么快的。我采用 GitHub Actions 同步到腾讯云对象存储中，直接用对象存储的链接进行访问，感觉这样并没有比采用加速域名走 CDN 慢。</p><p>目前没有用 memcached 或者 redis 作内容缓存，其一是并没有很大的并发需求，其二是 Typecho 没有好用的插件（或多或少有一些问题）。</p><h3 id="5-2-Google-BBR"><a href="#5-2-Google-BBR" class="headerlink" title="5.2 Google BBR"></a>5.2 Google BBR</h3><p>Google BBR 是一个 TCP 加速优化工具，可用于优化TCP连接，根据介绍开启可以加快访问的网速，这里参考了 <a href="https://www.moerats.com/archives/297/" target="_blank" rel="noopener">Rat 介绍的方法</a>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改系统变量</span></span><br><span class="line">echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存生效开启 BBR</span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看内核是否已开启 BBR</span></span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 BBR 是否启动</span></span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>显示以下即内核已开启 BBR：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sysctl net.ipv4.tcp_available_congestion_control</span></span><br><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></table></figure><p>显示类似以下内容即 BBR 启动成功：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lsmod | grep bbr</span></span><br><span class="line">tcp_bbr                20480  14</span><br></pre></td></tr></table></figure><h3 id="5-3-TLS-与-HSTS"><a href="#5-3-TLS-与-HSTS" class="headerlink" title="5.3 TLS 与 HSTS"></a>5.3 TLS 与 HSTS</h3><p>宝塔面板安装最新版本，Nginx 安装 1.17 版本的话，应该已经支持了 TLS 1.3 协议，可以在 <a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">ssllabs.com</a> 或者 <a href="https://myssl.com/" target="_blank" rel="noopener">myssl.com</a> 测试一下自己的站点。为了在上述测试中实现 A+ 的评级，获得 SSL 证书后，我还在 Nginx 中进行了如下的设置。</p><p>禁用 TLS 1.1 协议：删除服务器所有网站 Nginx 配置文件中的 <code>TLSv1.1</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;</span></span><br><span class="line"><span class="addition">+ssl_protocols TLSv1.2 TLSv1.3;</span></span><br></pre></td></tr></table></figure><p>使用 HSTS：在服务器所有网站 Nginx 配置文件中的 Server 括号内添加如下内容（如在 SSL 配置下方添加）。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#HSTS</span></span><br><span class="line"><span class="attribute">add_header</span> Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains"</span> always;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>科技树</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>服务器</tag>
        <tag>Typecho</tag>
      </tags>
  </entry>
  <entry>
    <title>全球新冠肺炎的扩散与防疫观察</title>
    <url>//posts/2020/03/29/2020-45-%E5%85%A8%E7%90%83%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E%E7%9A%84%E6%89%A9%E6%95%A3%E4%B8%8E%E9%98%B2%E7%96%AB%E8%A7%82%E5%AF%9F/</url>
    <content><![CDATA[<p>从一月开始蔓延的新冠病毒疫情至今已经两个多月了，本以为随着中国疫情的逐渐缓和，病毒蔓延得到了控制，生活也可以逐渐恢复正常了，谁知道本月以来疫情在全世界扩散开来。从一开始报道的韩国新天地教会疫情，到如今的美国、意大利确诊病例纷纷超越中国，形势也是越来越严峻。这个新冠肺炎疫情已经变成了一场影响全球经济社会发展的重大挑战。<a id="more"></a></p><h2 id="香港应对疫情的魔幻"><a href="#香港应对疫情的魔幻" class="headerlink" title="香港应对疫情的魔幻"></a>香港应对疫情的魔幻</h2><p>全国舆论对于新冠肺炎疫情的广泛关注起始于一月下旬（也即农历除夕前夕），随着武汉封城而进入顶峰。在此之前，香港媒体对此进行了比较集中的报道，当然这其中除了「跑得快」这个因素外，不外乎是对报道宣传内地负面新闻的热衷罢了。</p><p>香港媒体的这种报道确实让一部分香港民众对疫情产生了一定的关注，我认识的几个香港本地同学还曾特地向我询问内地疫情的情况。然而当时属于过年前的那段时间，香港刚刚从去年底的混乱中恢复过来，内地媒体也报道说「没有明确的人传人的证据」，所以我本人也没有对此引起更多的重视。</p><p>其实香港媒体最初对于疫情的关注，并没有让香港民众对本次新冠肺炎疫情产生足够的、提前的重视与防范，更多人是以一种看客的心态看待这次的疫情，甚至有人是幸灾乐祸的。这导致在一开始内地疫情极为严重的时候，香港激进本土派为代表的群体以「全面封关」为诉求口号，谋求香港对内地的封闭和拒绝内地人士访港。</p><p>这种不是真正出于公共卫生角度考量，而是带有政治目的的防疫诉求自然是得不到香港政府的认可，于是他们联合「黄色」医护人员开始进行医护届「罢工」来对政府施压。疫情当前，香港医护届似乎忘记了希波克拉底誓词（Hippocratic Oath）的字句，把政治利益放在了高于病患生命健康的地位。也不知道，他们选择医生、护士作为自己职业的时候，有没有那么一丝丝救死扶伤、治病救人的理想与追求？</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/03/hongkong.jpg!400x" alt="香港最新的防疫政策"></p><p>当时间进入三月中下旬中国内地的疫情得到了比较有效的控制之时，海外的疫情却面临四处爆发的局面。境外输入性风险不断加大，美欧日等地确诊病例逐日攀升，而香港确诊人数则多日位居全国首位。可是这时候，我们似乎听不到这些人主动提出要求对海外「全面封关」的诉求了。港府近期多次发布严格的防疫政策（如禁止多人集会、持牌酒肆禁止贩酒等），可是这些人依旧没有少出门、少聚会，除了戴口罩外依旧在上街示威与警察发生对抗冲突，还对港府各项防疫政策冷嘲热讽，不得不让人对香港近期的防疫产生一丝的担忧。</p><p>香港从去年底「蒙面违法」，到如今的「必须戴口罩」；而各个学校从去年底的混乱中停课，到如今因为疫情而继续停课，不能不说是一种魔幻了。</p><h2 id="新媒体时代的新挑战"><a href="#新媒体时代的新挑战" class="headerlink" title="新媒体时代的新挑战"></a>新媒体时代的新挑战</h2><p>在这次应对疫情当中，湖北省、武汉市当地一开始的工作确实不尽如人意。从新闻中可以看出，当地政府在应对新闻舆情、面对媒体方面依然不熟悉。新媒体、自媒体时代地方政府应对疫情的同时必然要直面媒体的监督和回应舆论的讨论。湖北、武汉在这方面出现的问题其实也不仅仅是当地特有的，很多地方其实都存在这方面的问题。</p><p>当然我们也看到那些熟悉本地区实际情况，能够清楚明白阐述自己的政策措施，及时调整工作不足回应舆论监督的官员得到了广大人民群众的热烈赞誉。例如，河南省省长的全省防控工作、天津疾控的张颖主任在流行病学调查中的细致追踪、温州市市长在《新闻1+1》上清楚阐述本地区的防控工作困难与应对措施、杭州市副市长用图表手板开新闻发布会等等。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/03/hangzhou.jpg!500x" alt="杭州市副市长陈卫强"></p><p>所以说，现在的网民也不是只会一味指责的。如果有好的表现，大家同样会给予赞扬的言语。这不是还有网友表示要去「偷省长」了吗？防疫与宣传是同样重要的两件事情，控制好流行传染性疾病不仅仅是医疗上的控制，更多的是要加强对社会各界的公共卫生教育和引导。</p><p>在人人都是媒体，大家都可以发表意见，时时刻刻都在监督工作的时代，如何将自己做过的、正在做的、将要做的、以及希望民众去做的准确完整清楚地阐述传达，或许是各地政府官员都需要重视的思考和问题了。这不仅仅是监督政府工作要求的，也是促进维护社会稳定、引导群众舆论出发要考虑的，还是一种不错的自我宣传方式。</p><h2 id="戴口罩与群体免疫"><a href="#戴口罩与群体免疫" class="headerlink" title="戴口罩与群体免疫"></a>戴口罩与群体免疫</h2><p>随着疫情在三月份开始全球范围内的蔓延扩散，大家都在说要外国人民和政府「抄作业」。中国防疫表现不能说满分，但是目前和国外比起来确实优秀许多了。</p><p>最关键也是最容易做到的戴口罩问题，中国是直接要求民众出门一定要戴口罩，纵使前期口罩不足也没有改变这一措施。而且「全民戴口罩」这一措施似乎仅仅在包括港澳台在内全中国范围内有共识，国外很多人都认为健康的人不需要戴口罩。确实，严格说口罩只需要患病的人戴，健康的人不需要戴。</p><p>但是，这是建立在所有患病病人都会自觉佩戴口罩，而且感染病毒即发病基础之上的。事实上，并不是发病的患者都会主动佩戴口罩，而且现在大量数据表明新冠病毒感染有潜伏期，并不一定出现临床症状，甚至有很多是无症状感染者，所以我们无法知道谁病了。有一个办法可以解决，那就是全民戴口罩，这样就能让所有带病毒的人，不把飞沫传播到空气中，同时因为没病的人也因为戴口罩，降低呼入病毒飞沫。</p><p>当然也有人说人人戴口罩，并不代表人人都会戴口罩。而且戴口罩的人容易不自觉触碰口罩外侧，然后接触口鼻眼睛，增加感染几率。可是如果仅仅因为一点小小的不足而无视全民戴口罩政策带来的巨大效果，似乎十分不合理不应该吧？这样的道理各国精英和领导人会不知道吗？精英怎么可能不知道，只不过因为口罩不够用就骗平民说不需要戴口罩；因为医院床位不够，就骗民众说群体免疫好。</p><p>说到群体免疫，英国政府简直是身先士卒、以身作则！鲍里斯前脚刚说完群体免疫政策好，不过大家要做好失去亲人的准备；后脚就发现大嘤的「太子」居然也感染了！「决赛圈」比赛瞬间紧张激烈起来了。正在大家还在震惊，还在担心老佛爷身体状况的时候，又传出首相（中堂大人）和卫生大臣（太医院）相继感染。 <del>庚子年果真是不太平！</del> 不对，应该是群体免疫本来就是投降主义，就是放弃的政策，是对本国人民和全球公共卫生的不负责任。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/03/uk.jpg!400x" alt=""></p><h2 id="走在前列的浙江行动"><a href="#走在前列的浙江行动" class="headerlink" title="走在前列的浙江行动"></a>走在前列的浙江行动</h2><p>中国在经历了2019年与美国全面性贸易战后，贸易谈判取得一定成果，与美国初步达成了贸易协议。看似贸易战可以缓一缓了，结果开年迎来疫情的重大打击，许多企业迟迟不能复工复产，经济面临严重的挑战，实现预期增长目标似乎已经不太可能。特别是对于浙江这种中小企业众多的省份，面临的困难更多。</p><p>作为浙江人，观察到浙江省在面对疫情后的恢复工作上是十分积极的。健康码，这一简化健康申报流程工作，加快人员监测的创新最先出现在浙江的疫情防控工作中，政企合作开发，全省乃至全国推广。浙江还首创「五色图」精准评估县域疫情风险等级，实现了对各地区疫情防治工作的分级管理。浙江多个县市政府也在疫情缓和之后，开展了「抢人」行动，前出几个劳动力输出大省，主动与当地对接「新浙江人」返回浙江的工作，包车运送到工作单位。这样的方式既帮助企业在困难时期尽快恢复生产，也减少了员工复工路上受到感染的风险。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/03/zhejiang.png!600x" alt="浙江省疫情五色图"></p><p>此外，浙江省在预防境外输入性病例方面也十分主动。在我老家，各个社区通过公安局出入境部门提供的本辖区内申领出入境证件记录，逐一落实情况，询问回不回来、如果回来什么时候回来（要去接机安排隔离）。我自己就在最近接到了分别来自社区和来自县公安局出入境部门的两个电话，爸妈那边也接到了一次社区打来的电话，同时还让我们进行网上信息登记。这样细致的工作，也让我在外面对爸妈更加放心了。</p><h2 id="考场并不只是在防疫"><a href="#考场并不只是在防疫" class="headerlink" title="考场并不只是在防疫"></a>考场并不只是在防疫</h2><p>或许谁也料想不到，2020年会以这样的方式开局。这一场遍及全球的传染病大流行，不仅仅是对医疗和公共卫生领域的考验，更是对整个社会的全面性挑战。</p><p>日本原定于今年夏季举办东京奥运会，也寄希望于通过奥运会拯救陷入低迷多年的经济。之前疫情出现上升势头时候大家就在讨论日本要不要推迟举办奥运会，可是东京方面一直不愿意松口，还按期开始了奥运圣火传递。后来在多国因为疫情严重宣布不参加奥运会的情况下，日本终于松口与国际奥委会达成共识推迟奥运会到明年举办。就在宣布奥运会、残奥会延期之后，却看到了日本特别是东京的确诊病例一下子增加了，甚至日本政府还说未来几周将迎来疫情高峰。这不得不让人怀疑，之前日本设置极高的检测门槛，疫情看似平缓，其实可能完全是因为「一切为了两会」。</p><p>韩国宗教，特别是基督教新教十分兴盛。而由于新教的特点和韩国政府的放任管理，基于新教而产生的邪教更是形形色色、多种多样。这次韩国的「新天地」教会引发的大规模群体性感染，一下子把韩国的邪教问题暴露了出来。一句「哈利路亚」，似乎就可以获得免疫的能力，甚至去鼓励教徒不顾政府禁令到处走动散播病毒。「宗教」开始侵入政权的范围，干预政治权力的运作的时候，这个国家是十分危险的。不过，幸好这次的韩国总统是文在寅而不是朴槿惠，抵抗住了各色「宗教」的压力，强势推动政府防疫政策。目前来看，韩国的疫情大致是被控制住了。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/03/korea.jpg!300x" alt="全光勋：哈利路亚！"></p><p>中国在疫情发生后就宣布了新冠病毒感染的肺炎救治费用，在医保报销后的差额由财政全额负担，也就是说对普通民众而言治疗是全免费的。事实上，在国家财政承受范围之内，对于大规模的流行传染病进行免费救治，可以避免一部分人因为经济负担而逃避治疗，从而避免可能导致的更大范围传染。但是，在这次疫情中，我们看到欧美国家在对新冠肺炎的诊断上就在讨论是否要免费，更不用说是不是要进行免费治疗。高昂的治疗费用让很多人望而却步，甚至能否获得检测确诊都变得十分困难。可是另一方面，我看到很多精英人士仅仅是因为有了轻微症状就得到了检测和确诊。</p><p>这里，不仅仅是医保制度的问题，其实还有是否决定要以牺牲经济来保障公共卫生防疫的考量。中国选择了以巨大的经济牺牲来换取对疫情的控制，而欧美很多国家的政治决策者显然更加偏向于保障经济发展。这里不能完全说孰是孰非，比较各自国情不同有不同的考量。但是，「佛系」的抗议不代表不作为，更不代表对人民生命的漠视和放弃。我们看到许多国家因为医疗系统被沉重的疫情击穿时候，不得不放弃对65岁以上老人的治疗。「时代的一粒灰，落在个人头上，就是一座山。对现在还挣扎在痛苦中的人们，谈生活太奢侈了，有些时候，光是活着，就已经拼尽全力。」这是某些人说中国的疫情时候曾说的话，而这句话其实现在看来更加适用于目前的欧美部分国家。</p><p>中世纪黑死病的流行和宗教谎言的破灭，让人们开始启蒙觉醒，从而打破了天主教对人们的枷锁，出现了文艺复兴。当年人们跑到郊外躲避瘟疫，住在一起的人们每人每天讲一个故事来渡过酷热的日子，成就了《十日谈》。这些故事中除了对于现实生活的描写、爱情的称扬、商人的智慧和才干之外，同时对于当时的帝王、贵族、教会等等势力的黑暗面加以揭露讽刺。那么，现在躲避疫情而宅在家里的欧美人们，面对现在他们政府和精英阶层防疫的政策，是否会有所思考，而成就新一部《十日谈》呢？我们拭目以待。</p><p><img data-src="https://web-1256060851.cos.ap-shanghai.myqcloud.com/posts/2020/03/decameron.jpg!500x" alt="《十日谈》插画"></p>]]></content>
      <categories>
        <category>观察者</category>
      </categories>
      <tags>
        <tag>政治</tag>
        <tag>COVID19</tag>
        <tag>公共卫生</tag>
      </tags>
  </entry>
  <entry>
    <title>hello</title>
    <url>//posts/2020/09/26/2020-51-hello/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>时光</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>helloword</title>
    <url>//posts/2020/09/26/2020-helloword/</url>
    <content><![CDATA[<p>测试工程师一个模式还是饿<br>eeeee</p><a id="more"></a><h3 id="ceshi"><a href="#ceshi" class="headerlink" title="ceshi"></a>ceshi</h3><p>ddjieijdd<br>ddjdfjifjdifjidjifjdijf<br>djfif</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">dddddddddddddddddd</span></span><br><span class="line"><span class="attribute">d</span></span><br><span class="line"><span class="attribute">d</span></span><br><span class="line"><span class="attribute">d</span></span><br><span class="line"><span class="attribute">d</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">d</span></span><br></pre></td></tr></table></figure><p>``</p>]]></content>
  </entry>
</search>
